#include<linux/init.h>
#include<linux/module.h>
#include<linux/version.h>
#include<linux/kernel.h>
#include<linux/types.h>
#include<linux/device.h>
#include<linux/fs.h>
#include<linux/kdev_t.h>
#include<linux/cdev.h>
#include<linux/random.h>
#include <linux/uaccess.h>
#include "chardev.h"

#define SUCCESS 0


static dev_t i2c;
static struct cdev c_dev;
static struct class *cls;
static uint16_t ch = 0;
static char al = 'r';
static int Device_Open = 0;
uint16_t randomgenerator(void);


static int i2c_open(struct inode *i,struct file *f){
		if (Device_Open)
        		return -1;

    		Device_Open++;
		return SUCCESS;
	}


static int i2c_close(struct inode *i,struct file *f){
		Device_Open--;
		return SUCCESS;

	}


static ssize_t i2c_read(struct file *f, char __user *buf, size_t len, loff_t *off){
    	uint16_t randno;
    	randno = randomgenerator();
	printk(KERN_INFO " random number generated by driver is %d",randno);
}
    	


long i2c_ioctl(struct file *file,unsigned int ioctl_num,unsigned long ioctl_param){

                switch(ioctl_num){
			case G_X_AXIS_IOR:
			
			printk(KERN_INFO"reading of gyroscope in x axis %u",randomgenerator());
			break;
			case GYRO_Y_AXIS_IOR:
			
			printk(KERN_INFO"reading of gyroscope in y axis %u",randomgenerator());
			break;
			case GYRO_Z_AXIS_IOR:
		
			printk(KERN_INFO"reading of gyroscope in z axis %u",randomgenerator());
			break;
                 	case  COMPASS_X_AXIS:
			printk(KERN_INFO"reading of compass in x axis %u",randomgenerator());
			break;
			case  COMPASS_Y_AXIS:
			printk(KERN_INFO"reading of compass in y axis %u",randomgenerator());
			break;
			case  COMPASS_Z_AXIS:
			printk(KERN_INFO"reading of compass in z axis %u",randomgenerator());
			break;
			case  ACCELEROMETER_X_AXIS:
			printk(KERN_INFO"reading of accelerometer in x axis %u",randomgenerator());
			break;
			case  ACCELEROMETER_Y_AXIS:
			printk(KERN_INFO"reading of accelerometer in y axis %u",randomgenerator());
			break;
			case  ACCELEROMETER_Z_AXIS:
			printk(KERN_INFO"reading of accelerometer in z axis %u",randomgenerator());
			break;
			case BAROMETER :
			printk(KERN_INFO"reading of barometer  %u",randomgenerator());
			break;
			
                }
              return SUCCESS;
  }
//function to generate random numbers

uint16_t randomgenerator(void){
    unsigned int num;
    get_random_bytes(&num, 2);
    num%=1023;
    return (uint16_t)num;
  }

static struct file_operations fops =
					{
					.owner = THIS_MODULE,
					.open = i2c_open,
					.release = i2c_close,
                                        .unlocked_ioctl = i2c_ioctl,
					.read = i2c_read
					};

__init int i2cdriver_init(void){
	// Step 1: Allocation of major and minor numbers.
	if(alloc_chrdev_region(&i2c,0,1,"imu_char")<0){
		return -1;
	}
	printk(KERN_INFO "<major , minor>:<%d,%d>\n",MAJOR(i2c),MINOR(i2c));// to see the alloted major and minor no.

	// Step 2: Creation of device file.
	if((cls=class_create(THIS_MODULE,"i2cclass"))==NULL){
		printk(KERN_INFO "Failed to create class......exiting");
			unregister_chrdev_region(i2c,1);
			return -1;
	}
	if((device_create(cls,NULL,i2c,NULL,"i2c8"))==NULL){
		printk(KERN_INFO "Failed to create device......exiting");
			class_destroy(cls);
			unregister_chrdev_region(i2c,1);
			return -1;
	}
	//Step 3: Link fops and cdev to device node;
	cdev_init(&c_dev,&fops);
	//making the driver live
	if(cdev_add(&c_dev,i2c, 1)==-1){
		device_destroy(cls,i2c);
		class_destroy(cls);
		unregister_chrdev_region(i2c,1);
			printk(KERN_INFO "Failed to make driver live ......exiting");
		return -1;
	}
	printk(KERN_INFO "Inserted successfully Congratulations");
	return SUCCESS;
}


__exit void i2cdriver_exit(void){
	cdev_del(&c_dev);
	device_destroy(cls,i2c);
	class_destroy(cls);
	printk(KERN_INFO "entered in exit routine");
	unregister_chrdev_region(i2c,1);
	printk(KERN_INFO "Deleted successfully");
}


module_init(i2cdriver_init);
module_exit(i2cdriver_exit);
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("IMU driver");
MODULE_AUTHOR("ABHISHEK KUMAR GAURAV");
